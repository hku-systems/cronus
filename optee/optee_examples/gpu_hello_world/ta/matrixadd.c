#ifdef __KERNEL__ /* just for measurement */
#include <linux/vmalloc.h>
#include <linux/time.h>
#define printf printk
#define malloc vmalloc
#define free vfree
#define gettimeofday(x, y) do_gettimeofday(x)
#else /* just for measurement */
#include <sys/time.h>
#include <stdio.h>
#include <stdlib.h>
#endif
#include <unistd.h>
#include "gdev_api.h"

// This is generated by cudump
uint32_t kcode[] = {
	0x00017a02,
	0x00000a00,
	0x00000f00,
	0x000fc400,
	0x00067919,
	0x00000000,
	0x00002100,
	0x000e2200,
	0x00077802,
	0x00000004,
	0x00000f00,
	0x000fc600,
	0x00037919,
	0x00000000,
	0x00002200,
	0x000e2400,
	0x06067a24,
	0x00005e00,
	0x078e0203,
	0x001fc800,
	0x06027625,
	0x00005800,
	0x078e0207,
	0x000fc800,
	0x06047625,
	0x00005a00,
	0x078e0207,
	0x000fc800,
	0x02027381,
	0x00000000,
	0x001ee900,
	0x000ea800,
	0x04057381,
	0x00000000,
	0x001ee900,
	0x000ea200,
	0x06067625,
	0x00005c00,
	0x078e0207,
	0x000fe200,
	0x02097210,
	0x00000005,
	0x07ffe0ff,
	0x004fd000,
	0x06007386,
	0x00000009,
	0x0010e900,
	0x000fe200,
	0x0000794d,
	0x00000000,
	0x03800000,
	0x000fea00,
	0x00007947,
	0xfffffff0,
	0x0383ffff,
	0x000fc000,
	0x00007918,
	0x00000000,
	0x00000000,
	0x000fc000,
	0x00007918,
	0x00000000,
	0x00000000,
	0x000fc000,
};

uint32_t c0[] = {
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
	0x00000000,
};

#define PARAM_SIZE (sizeof(c0))
#define STACK_DEPTH 0xc
#define LOCAL_SIZE 0x0
#define SHARED_SIZE 0x0
#define REG_COUNT 0xc
#define BARRIER_COUNT 0x0
#define NVCC_PARAM_OFFSET 0x160

static inline unsigned __round_up_pow2(unsigned x)
{
	if (x == 0)
		return 0;
	x--;
	x |= x >> 1;
	x |= x >> 2;
	x |= x >> 4;
	x |= x >> 8;
	x |= x >> 16;

	return ++x;
}

int gdev_test_matrixadd(uint32_t *a, uint32_t *b, uint32_t *c, int n)
{
	int i, j, idx;
	uint32_t id;
	uint32_t mp_count = 0;
	uint32_t code_size, a_size, b_size, c_size;
	// uint32_t param_buf[PARAM_SIZE / 4];
	uint64_t a_addr, b_addr, c_addr;
	uint64_t result[3];

	Ghandle handle;
	struct gdev_kernel k;

	/* initialize A[] & B[] */
	for (i = 0; i < n; i++) {
		for(j = 0; j < n; j++) {
			idx = i * n + j;
			a[idx] = i;
			b[idx] = j;
		}
	}

	if (!(handle = gopen(0))) {
		return -1;
	}
	
	a_size = n * n * sizeof(uint32_t);
	b_size = n * n * sizeof(uint32_t);
	c_size = n * n * sizeof(uint32_t);

	if (!(a_addr = gmalloc(handle, a_size)))
		return -1;
	if (!(b_addr = gmalloc(handle, b_size)))
		return -1;
	if (!(c_addr = gmalloc(handle, c_size)))
		return -1;

	code_size = sizeof(kcode);
	if (code_size & 0xff)
		k.code_size = (code_size + 0x100) & ~0xff;
	else
		k.code_size = code_size;
	if (!(k.code_addr = gmalloc(handle, k.code_size)))
		return -1;
	k.code_pc = 0;

	k.cmem[0].size = PARAM_SIZE;
	if (k.cmem[0].size == 0 || k.cmem[0].size & 0xff)
		k.cmem[0].size = (k.cmem[0].size + 0x100) & ~0xff;
	if (!(k.cmem[0].addr = gmalloc(handle, k.cmem[0].size)))
		return -1;
	k.cmem[0].offset = 0;
	for (i = 1; i < GDEV_NVIDIA_CONST_SEGMENT_MAX_COUNT; i++) {
		k.cmem[i].addr = 0;
		k.cmem[i].size = 0;
		k.cmem[i].offset = 0;
	}
	k.cmem_count = GDEV_NVIDIA_CONST_SEGMENT_MAX_COUNT;
	k.param_size = PARAM_SIZE;
	k.param_buf = c0;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 0] = a_addr;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 1] = a_addr >> 32;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 2] = b_addr;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 3] = b_addr >> 32;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 4] = c_addr;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 5] = c_addr >> 32;
	k.param_buf[NVCC_PARAM_OFFSET/4 + 6] = n;

	k.lmem_size = LOCAL_SIZE;
	if (k.lmem_size & 0xf)
		k.lmem_size = (k.lmem_size + 0x10) & ~0xf;
	k.lmem_size_neg = 0; /* just random */
	if (k.lmem_size_neg & 0xf)
		k.lmem_size_neg = (k.lmem_size_neg + 0x10) & ~0xf;
	k.lmem_base = 0x01000000;
	k.smem_size = SHARED_SIZE;
	if (k.smem_size & 0x7f)
		k.smem_size = (k.smem_size + 0x80) & (~0x7f);
	k.smem_base = 0x0;
	
	k.warp_stack_size = (STACK_DEPTH + 0x1000) & (~0xfff);
	
	/* FIXME: per-thread warp size may differ from 32. */
	k.warp_lmem_size = 32 * (k.lmem_size + k.lmem_size_neg) + k.warp_stack_size; 
	
	/* FIXME: the number of active warps may differ from 48. */
	gquery(handle, GDEV_NVIDIA_QUERY_MP_COUNT, (uint64_t *)&mp_count);
	if (!mp_count) mp_count = 32;
	k.lmem_size_total = 48 * mp_count * k.warp_lmem_size;
	k.lmem_size_total = __round_up_pow2(k.lmem_size_total);
	if (!(k.lmem_addr = gmalloc(handle, k.lmem_size_total)))
		return -1;

	k.reg_count = REG_COUNT;
	k.bar_count = BARRIER_COUNT;
	k.grid_id = 1;
	
	k.block_x = n < 16 ? n : 16;
	k.block_y = n < 16 ? n : 16;
	k.block_z = 1;
	k.grid_x = n / k.block_x;
	if (n % k.block_x != 0)
		k.grid_x++;
	k.grid_y = n / k.block_y;
	if (n % k.block_y != 0)
		k.grid_y++;
	k.grid_z = 1;

	gmemcpy_to_device(handle, k.code_addr, kcode, k.code_size);
	gmemcpy_to_device(handle, a_addr, a, a_size);
	gmemcpy_to_device(handle, b_addr, b, b_size);
	
	glaunch(handle, &k, &id);
	gsync(handle, id, NULL);
	
	gmemcpy_from_device(handle, c, c_addr, c_size);

	i = j = idx = 0;
	for (i = 0;i < n;i++) {
		for (j = 0;j < n;j++) {
			idx = i * n + j;
			if (c[idx] != a[idx] + b[idx]) {
				printf("a[%d]+b[%d] = %d != c[%d] = %d\n", idx, idx, a[idx]+b[idx], idx, c[idx]);
		//		return -1;
			} else {
				printf("a[%d]+b[%d] = %d\n", idx, idx, a[idx]+b[idx]);
			}
		}
	}

	gfree(handle, a_addr);
	gfree(handle, b_addr);
	gfree(handle, c_addr);
	gfree(handle, k.code_addr);
	gfree(handle, k.cmem[0].addr);
	gfree(handle, k.lmem_addr);
	
	gclose(handle);

	return 0;
}
